{
    "docs": [
        {
            "location": "/", 
            "text": "GenomicFeatures.jl\n\n\n\n\nDescription\n\n\nGenomicFeatures.jl provides genomic interval arithmetic, data structures, and I/O tools for various data formats including BED, GFF3, bigWig, and bigBed.\n\n\n\n\nInstallation\n\n\nInstall GenomicFeatures from the Julia REPL:\n\n\njulia\n \nPkg\n.\nadd\n(\nGenomicFeatures\n)\n\n\n\n\n\n\nIf you are interested in the cutting edge of the development, please check out the master branch to try new features before release.", 
            "title": "Home"
        }, 
        {
            "location": "/#genomicfeaturesjl", 
            "text": "", 
            "title": "GenomicFeatures.jl"
        }, 
        {
            "location": "/#description", 
            "text": "GenomicFeatures.jl provides genomic interval arithmetic, data structures, and I/O tools for various data formats including BED, GFF3, bigWig, and bigBed.", 
            "title": "Description"
        }, 
        {
            "location": "/#installation", 
            "text": "Install GenomicFeatures from the Julia REPL:  julia   Pkg . add ( GenomicFeatures )   If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.", 
            "title": "Installation"
        }, 
        {
            "location": "/intervals/", 
            "text": "Intervals: Genomic Interval Manipulation\n\n\nThe \nIntervals\n module consists of tools for working efficiently with genomic intervals.\n\n\n\n\nInterval types\n\n\nIntervals in Bio.jl are consistent with ranges in Julia: \n1-based and end-inclusive\n. When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.\n\n\nThe \nInterval\n type is defined as\n\n\nimmutable\n \nInterval\n{\nT\n}\n \n:\n \nAbstractInterval\n{\nInt64\n}\n\n    \nseqname\n::\nString\n\n    \nfirst\n::\nInt64\n\n    \nlast\n::\nInt64\n\n    \nstrand\n::\nStrand\n\n    \nmetadata\n::\nT\n\n\nend\n\n\n\n\n\n\nThe first three fields (\nseqname\n, \nfirst\n, and \nlast\n) are mandatory arguments when constructing an \nInterval\n object. \nseqname\n is the sequence name associated with the interval. The \nfirst\n and \nlast\n fields are the leftmost and rightmost positions of the interval, which can be accessed with \nleftposition\n and \nrightposition\n functions, respectively.\n\n\nThe \nstrand\n field can take four kinds of values listed in the next table:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'?'\n\n\nSTRAND_NA\n\n\nstrand is unknown or inapplicable\n\n\n\n\n\n\n'+'\n\n\nSTRAND_POS\n\n\npositive strand\n\n\n\n\n\n\n'-'\n\n\nSTRAND_NEG\n\n\nnegative strand\n\n\n\n\n\n\n'.'\n\n\nSTRAND_BOTH\n\n\nnon-strand-specific feature\n\n\n\n\n\n\n\n\nSimilarly to the \nSeqRecord\n type in the \nBio.Seq\n module, \nInterval\n is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.\n\n\nThe default strand and metadata values are \nSTRAND_BOTH\n and \nnothing\n:\n\n\njulia\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n)\n\n\nGenomicFeatures.Interval{Void}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: .\n\n\n  metadata: nothing\n\n\n\njulia\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n,\n \n+\n)\n\n\nGenomicFeatures.Interval{Void}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: +\n\n\n  metadata: nothing\n\n\n\n\n\n\nThe following example shows all accessor functions for the five fields:\n\n\njulia\n \ni\n \n=\n \nInterval\n(\nchr1\n,\n \n10000\n,\n \n20000\n,\n \n+\n,\n \nsome annotation\n)\n\n\nGenomicFeatures.Interval{String}:\n\n\n  sequence name: chr1\n\n\n  leftmost position: 10000\n\n\n  rightmost position: 20000\n\n\n  strand: +\n\n\n  metadata: some annotation\n\n\n\njulia\n \nseqname\n(\ni\n)\n\n\nchr1\n\n\n\njulia\n \nleftposition\n(\ni\n)\n\n\n10000\n\n\n\njulia\n \nrightposition\n(\ni\n)\n\n\n20000\n\n\n\njulia\n \nstrand\n(\ni\n)\n\n\nSTRAND_POS\n\n\n\njulia\n \nmetadata\n(\ni\n)\n\n\nsome annotation\n\n\n\n\n\n\n\n\nCollections of intervals\n\n\nCollections of intervals are represented using the \nIntervalCollection\n type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.\n\n\nInterval collections can be initialized by inserting elements one by one using \npush!\n.\n\n\n# The type parameter (Void here) indicates the interval metadata type.\n\n\nincol\n \n=\n \nIntervalCollection\n{\nVoid\n}()\n\n\n\nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n\n    \npush!\n(\nincol\n,\n \nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n))\n\n\nend\n\n\n\n\n\n\nIncrementally building an interval collection like this works, but \nIntervalCollection\n also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.\n\n\nincol\n \n=\n \nIntervalCollection\n([\nInterval\n(\nchr1\n,\n \ni\n,\n \ni\n \n+\n \n99\n)\n \nfor\n \ni\n \nin\n \n1\n:\n100\n:\n10000\n])\n\n\n\n\n\n\nBulding \nIntervalCollections\n in one shot like this should be preferred when it's convenient or speed in an issue.\n\n\nIntervalCollection\ns can also be build directly from a genome annotation file, here in GFF3 format:\n\n\nrdr\n \n=\n \nopen\n(\nGFF3\n.\nReader\n,\n \nsome_genome.gff3\n)\n\n\nfeatures\n \n=\n \nIntervalCollection\n(\nrdr\n)\n\n\n\n\n\n\n\n\nIntersection\n\n\nThere are number of \neachoverlap\n function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of overlapping intervals.\n\n\n#\n\n\nGenomicFeatures.eachoverlap\n \n \nFunction\n.\n\n\neachoverlap(intervals_a, intervals_b, [seqname_isless=Base.isless])\n\n\n\n\n\nCreate an iterator of overlapping intervals between \nintervals_a\n and \nintervals_b\n.\n\n\nThis function assumes elements of \nintervals_a\n and \nintervals_b\n are sorted by its sequence name and left position.  If the element type is not a subtype of \nGenomicFeatures.Interval\n, elements are converted to \nInterval\n objects.\n\n\nThe third optional argument is a function that defines the order of sequence names. The default function is \nBase.isless\n, which is the lexicographical order.\n\n\nsource\n\n\nThe order of interval pairs is the same as the following nested loop but \neachoverlap\n is often much faster:\n\n\nfor\n \na\n \nin\n \nintervals_a\n,\n \nb\n \nin\n \nintervals_b\n\n    \nif\n \nisoverlapping\n(\na\n,\n \nb\n)\n\n        \n# do something...\n\n    \nend\n\n\nend\n\n\n\n\n\n\n\n\nInterval streams\n\n\nIntervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.\n\n\nThe Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An \nIntervalCollection\n is also an interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \neachoverlap\n(\nopen\n(\nBED\n.\nReader\n,\n \nx_features.bed\n),\n \nopen\n(\nBED\n.\nReader\n,\n \ny_features.bed\n))\n\n    \nprintln\n(\nIntersection found between \n,\n \nx\n,\n \n and \n,\n \ny\n)\n\n\nend\n\n\n\n\n\n\nAn exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a \nBase.isless\n comparison function that is a default order in most command-line tools. The Intervals module also offers \nalphanum_isless\n comparison that compares numbers numerically if they exist in string, so that names like \nchr1, chr2, chr10\n end up in their natural order.\n\n\nThe \neachoverlap\n function takes as an optional parameter an \nisless\n function to use to compare sequence names to account for arbitrary sequence name orderings.\n\n\nfor\n \n(\nx\n,\n \ny\n)\n \nin\n \neachoverlap\n(\nxs\n,\n \nys\n,\n \nGenomicFeatures\n.\nalphanum_isless\n)\n\n    \nprintln\n(\nIntersection found between \n,\n \na\n,\n \n and \n,\n \nb\n)\n\n\nend\n\n\n\n\n\n\nA special sort of intersection can also be performed on an interval stream against itself to produce \"coverage intervals\".\n\n\n#\n\n\nGenomicFeatures.coverage\n \n \nFunction\n.\n\n\ncoverage(intervals)\n\n\n\n\n\nCompute the coverage of a collection of intervals and return an \nIntervalCollection\n that contains run-length encoded coverage data.\n\n\nFor example, given intervals like:\n\n\n[------]     [------------]\n\n   \n[---------------]\n\n\n\n\n\n\nThis function would return a new set of disjoint intervals with annotated coverage like:\n\n\n[1][-2-][-1-][--2--][--1--]\n\n\n\n\n\nsource", 
            "title": "Intervals"
        }, 
        {
            "location": "/intervals/#intervals-genomic-interval-manipulation", 
            "text": "The  Intervals  module consists of tools for working efficiently with genomic intervals.", 
            "title": "Intervals: Genomic Interval Manipulation"
        }, 
        {
            "location": "/intervals/#interval-types", 
            "text": "Intervals in Bio.jl are consistent with ranges in Julia:  1-based and end-inclusive . When data is read from formats with different representations (i.e. 0-based and/or end-exclusive) they are always converted automatically. Similarly when writing data. You should not have to reason about off-by-one errors due to format differences while using functionality provided in Bio.jl.  The  Interval  type is defined as  immutable   Interval { T }   :   AbstractInterval { Int64 } \n     seqname :: String \n     first :: Int64 \n     last :: Int64 \n     strand :: Strand \n     metadata :: T  end   The first three fields ( seqname ,  first , and  last ) are mandatory arguments when constructing an  Interval  object.  seqname  is the sequence name associated with the interval. The  first  and  last  fields are the leftmost and rightmost positions of the interval, which can be accessed with  leftposition  and  rightposition  functions, respectively.  The  strand  field can take four kinds of values listed in the next table:     Symbol  Constant  Meaning      '?'  STRAND_NA  strand is unknown or inapplicable    '+'  STRAND_POS  positive strand    '-'  STRAND_NEG  negative strand    '.'  STRAND_BOTH  non-strand-specific feature     Similarly to the  SeqRecord  type in the  Bio.Seq  module,  Interval  is parameterized on metadata type, which lets it efficiently and precisely be specialized to represent intervals from a variety of formats.  The default strand and metadata values are  STRAND_BOTH  and  nothing :  julia   Interval ( chr1 ,   10000 ,   20000 )  GenomicFeatures.Interval{Void}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: .    metadata: nothing  julia   Interval ( chr1 ,   10000 ,   20000 ,   + )  GenomicFeatures.Interval{Void}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: +    metadata: nothing   The following example shows all accessor functions for the five fields:  julia   i   =   Interval ( chr1 ,   10000 ,   20000 ,   + ,   some annotation )  GenomicFeatures.Interval{String}:    sequence name: chr1    leftmost position: 10000    rightmost position: 20000    strand: +    metadata: some annotation  julia   seqname ( i )  chr1  julia   leftposition ( i )  10000  julia   rightposition ( i )  20000  julia   strand ( i )  STRAND_POS  julia   metadata ( i )  some annotation", 
            "title": "Interval types"
        }, 
        {
            "location": "/intervals/#collections-of-intervals", 
            "text": "Collections of intervals are represented using the  IntervalCollection  type, which is a general purpose indexed container for intervals. It supports fast intersection operations as well as insertion, deletion, and sorted iteration.  Interval collections can be initialized by inserting elements one by one using  push! .  # The type parameter (Void here) indicates the interval metadata type.  incol   =   IntervalCollection { Void }()  for   i   in   1 : 100 : 10000 \n     push! ( incol ,   Interval ( chr1 ,   i ,   i   +   99 ))  end   Incrementally building an interval collection like this works, but  IntervalCollection  also has a bulk insertion constructor that is able to build the indexed data structure extremely efficiently from an array of intervals.  incol   =   IntervalCollection ([ Interval ( chr1 ,   i ,   i   +   99 )   for   i   in   1 : 100 : 10000 ])   Bulding  IntervalCollections  in one shot like this should be preferred when it's convenient or speed in an issue.  IntervalCollection s can also be build directly from a genome annotation file, here in GFF3 format:  rdr   =   open ( GFF3 . Reader ,   some_genome.gff3 )  features   =   IntervalCollection ( rdr )", 
            "title": "Collections of intervals"
        }, 
        {
            "location": "/intervals/#intersection", 
            "text": "There are number of  eachoverlap  function in the Intervals module. They follow two patterns: interval versus collection queries which return an iterator over intervals in the collection that intersect the query, and collection versus collection queries which iterate over all pairs of overlapping intervals.  #  GenomicFeatures.eachoverlap     Function .  eachoverlap(intervals_a, intervals_b, [seqname_isless=Base.isless])  Create an iterator of overlapping intervals between  intervals_a  and  intervals_b .  This function assumes elements of  intervals_a  and  intervals_b  are sorted by its sequence name and left position.  If the element type is not a subtype of  GenomicFeatures.Interval , elements are converted to  Interval  objects.  The third optional argument is a function that defines the order of sequence names. The default function is  Base.isless , which is the lexicographical order.  source  The order of interval pairs is the same as the following nested loop but  eachoverlap  is often much faster:  for   a   in   intervals_a ,   b   in   intervals_b \n     if   isoverlapping ( a ,   b ) \n         # do something... \n     end  end", 
            "title": "Intersection"
        }, 
        {
            "location": "/intervals/#interval-streams", 
            "text": "Intervals need not necessarily stored in an indexed data structure for efficient intersection to be practical. Two collections of intervals need only be both sorted to compute all intersecting pairs. This is particularly useful in genomics where datasets are sometimes so large that loading them entirely into memory is not practical.  The Intervals module is able to intersect any two iterators that yield intervals in sorted order, which we refer to as \"interval streams\". An  IntervalCollection  is also an interval stream, but so is a sorted array of intervals, and parsers over interval file formats. This allows for a very general notion of intersection.  for   ( x ,   y )   in   eachoverlap ( open ( BED . Reader ,   x_features.bed ),   open ( BED . Reader ,   y_features.bed )) \n     println ( Intersection found between  ,   x ,    and  ,   y )  end   An exception will be thrown if an interval in encountered out of order while processing an interval stream. Ordering of intervals has one complication: there is not necessarily a standardized way to order sequence names. By default in Bio.jl intervals are sorted using a  Base.isless  comparison function that is a default order in most command-line tools. The Intervals module also offers  alphanum_isless  comparison that compares numbers numerically if they exist in string, so that names like  chr1, chr2, chr10  end up in their natural order.  The  eachoverlap  function takes as an optional parameter an  isless  function to use to compare sequence names to account for arbitrary sequence name orderings.  for   ( x ,   y )   in   eachoverlap ( xs ,   ys ,   GenomicFeatures . alphanum_isless ) \n     println ( Intersection found between  ,   a ,    and  ,   b )  end   A special sort of intersection can also be performed on an interval stream against itself to produce \"coverage intervals\".  #  GenomicFeatures.coverage     Function .  coverage(intervals)  Compute the coverage of a collection of intervals and return an  IntervalCollection  that contains run-length encoded coverage data.  For example, given intervals like:  [------]     [------------] \n    [---------------]   This function would return a new set of disjoint intervals with annotated coverage like:  [1][-2-][-1-][--2--][--1--]  source", 
            "title": "Interval streams"
        }, 
        {
            "location": "/io/bed/", 
            "text": "BED\n\n\n\n\nReader type: \nBED.Reader\n\n\nWriter type: \nBED.Writer\n\n\nElement type: \nBED.Record\n\n\n\n\nBED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.\n\n\nThis is an example of RNA transcripts:\n\n\nchr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -\n\n\n\n\n\n#\n\n\nGenomicFeatures.BED.Reader\n \n \nType\n.\n\n\nBED.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the BED file format.\n\n\nArguments:\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.Writer\n \n \nType\n.\n\n\nBED.Writer(output::IO)\n\n\n\n\n\nCreate a data writer of the BED file format.\n\n\nArguments:\n\n\n\n\noutput\n: data sink\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.Record\n \n \nType\n.\n\n\nBED.Record()\n\n\n\n\n\nCreate an unfilled BED record.\n\n\nsource\n\n\nBED.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a BED record object from \ndata\n.\n\n\nThis function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nBED.Record(str::AbstractString)\n\n\n\n\n\nCreate a BED record object from \nstr\n.\n\n\nThis function verifies and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::String\n\n\n\n\n\nGet the chromosome name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.chromstart\n \n \nFunction\n.\n\n\nchromstart(record::Record)::Int\n\n\n\n\n\nGet the starting position of \nrecord\n.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.chromend\n \n \nFunction\n.\n\n\nchromend(record::Record)::Int\n\n\n\n\n\nGet the end position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.name\n \n \nFunction\n.\n\n\nname(record::Record)::String\n\n\n\n\n\nGet the name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.score\n \n \nFunction\n.\n\n\nscore(record::Record)::Int\n\n\n\n\n\nGet the score between 0 and 1000.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.strand\n \n \nFunction\n.\n\n\nstrand(record::Record)::GenomicFeatures.Strand\n\n\n\n\n\nGet the strand of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.thickstart\n \n \nFunction\n.\n\n\nthickstart(record::Record)::Int\n\n\n\n\n\nGet the starting position at which \nrecord\n is drawn thickly.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.thickend\n \n \nFunction\n.\n\n\nthickend(record::Record)::Int\n\n\n\n\n\nGet the end position at which \nrecord\n is drawn thickly.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.itemrgb\n \n \nFunction\n.\n\n\nitemrgb(record::Record)::ColorTypes.RGB\n\n\n\n\n\nGet the RGB value of \nrecord\n.\n\n\nThe return type is defined in \nColorTypes.jl\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.blockcount\n \n \nFunction\n.\n\n\nblockcount(record::Record)::Int\n\n\n\n\n\nGet the number of blocks (exons) in \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.blocksizes\n \n \nFunction\n.\n\n\nblocksizes(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) sizes of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BED.blockstarts\n \n \nFunction\n.\n\n\nblockstarts(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) starts of \nrecord\n.\n\n\nNote that the first base is numbered 1.\n\n\nsource", 
            "title": "BED"
        }, 
        {
            "location": "/io/bed/#bed", 
            "text": "Reader type:  BED.Reader  Writer type:  BED.Writer  Element type:  BED.Record   BED is a text-based file format for representing genomic annotations like genes, transcripts, and so on. A BED file has tab-delimited and variable-length fields; the first three fields denoting a genomic interval are mandatory.  This is an example of RNA transcripts:  chr9    68331023    68424451    NM_015110   0   +\nchr9    68456943    68486659    NM_001206   0   -  #  GenomicFeatures.BED.Reader     Type .  BED.Reader(input::IO)  Create a data reader of the BED file format.  Arguments:   input : data source   source  #  GenomicFeatures.BED.Writer     Type .  BED.Writer(output::IO)  Create a data writer of the BED file format.  Arguments:   output : data sink   source  #  GenomicFeatures.BED.Record     Type .  BED.Record()  Create an unfilled BED record.  source  BED.Record(data::Vector{UInt8})  Create a BED record object from  data .  This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  BED.Record(str::AbstractString)  Create a BED record object from  str .  This function verifies and indexes fields for accessors.  source  #  GenomicFeatures.BED.chrom     Function .  chrom(record::Record)::String  Get the chromosome name of  record .  source  #  GenomicFeatures.BED.chromstart     Function .  chromstart(record::Record)::Int  Get the starting position of  record .  Note that the first base is numbered 1.  source  #  GenomicFeatures.BED.chromend     Function .  chromend(record::Record)::Int  Get the end position of  record .  source  #  GenomicFeatures.BED.name     Function .  name(record::Record)::String  Get the name of  record .  source  #  GenomicFeatures.BED.score     Function .  score(record::Record)::Int  Get the score between 0 and 1000.  source  #  GenomicFeatures.BED.strand     Function .  strand(record::Record)::GenomicFeatures.Strand  Get the strand of  record .  source  #  GenomicFeatures.BED.thickstart     Function .  thickstart(record::Record)::Int  Get the starting position at which  record  is drawn thickly.  Note that the first base is numbered 1.  source  #  GenomicFeatures.BED.thickend     Function .  thickend(record::Record)::Int  Get the end position at which  record  is drawn thickly.  source  #  GenomicFeatures.BED.itemrgb     Function .  itemrgb(record::Record)::ColorTypes.RGB  Get the RGB value of  record .  The return type is defined in  ColorTypes.jl .  source  #  GenomicFeatures.BED.blockcount     Function .  blockcount(record::Record)::Int  Get the number of blocks (exons) in  record .  source  #  GenomicFeatures.BED.blocksizes     Function .  blocksizes(record::Record)::Vector{Int}  Get the block (exon) sizes of  record .  source  #  GenomicFeatures.BED.blockstarts     Function .  blockstarts(record::Record)::Vector{Int}  Get the block (exon) starts of  record .  Note that the first base is numbered 1.  source", 
            "title": "BED"
        }, 
        {
            "location": "/io/gff3/", 
            "text": "GFF3\n\n\n\n\nReader type: \nGenomicFeatures.GFF3.Reader\n\n\nWriter type: \nGenomicFeatures.GFF3.Writer\n\n\nElement type: \nGenomicFeatures.GFF3.Record\n\n\n\n\nGFF3 is a text-based file format for representing genomic annotations. The major difference from BED is that is GFF3 is more structured and can include sequences in the FASTA file format.\n\n\n#\n\n\nGenomicFeatures.GFF3.Reader\n \n \nType\n.\n\n\nGFF3Reader\n(\ninput\n::\nIO\n;\n \nsave_directives\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nCreate a reader for data in GFF3 format.\n\n\nArguments:\n\n\n\n\ninput\n: data source\n\n\nsave_directives=false\n: if true, store directive lines, which can be accessed with the \ndirectives\n function\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.Writer\n \n \nType\n.\n\n\nGFF3.Writer(output::IO)\n\n\n\n\n\nCreate a data writer of the GFF3 file format.\n\n\nArguments:\n\n\n\n\noutput\n: data sink\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.Record\n \n \nType\n.\n\n\nGFF3.Record()\n\n\n\n\n\nCreate an unfilled GFF3 record.\n\n\nsource\n\n\nGFF3.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a GFF3 record object from \ndata\n. This function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nGFF3.Record(str::AbstractString)\n\n\n\n\n\nCreate a GFF3 record object from \nstr\n. This function verifies and indexes fields for accessors.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.isfeature\n \n \nFunction\n.\n\n\nisfeature(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is a feature record.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.isdirective\n \n \nFunction\n.\n\n\nisdirective(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is a directive record.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.iscomment\n \n \nFunction\n.\n\n\niscomment(record::Record)::Bool\n\n\n\n\n\nTest if \nrecord\n is a comment record.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.seqid\n \n \nFunction\n.\n\n\nseqid(record::Record)::String\n\n\n\n\n\nGet the sequence ID of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.source\n \n \nFunction\n.\n\n\nsource(record::Record)::String\n\n\n\n\n\nGet the source of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.featuretype\n \n \nFunction\n.\n\n\nfeaturetype(record::Record)::String\n\n\n\n\n\nGet the type of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.seqstart\n \n \nFunction\n.\n\n\nseqstart(record::Record)::Int\n\n\n\n\n\nGet the start coordinate of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.seqend\n \n \nFunction\n.\n\n\nseqend(record::Record)::Int\n\n\n\n\n\nGet the end coordinate of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.score\n \n \nFunction\n.\n\n\nscore(record::Record)::Float64\n\n\n\n\n\nGet the score of \nrecord\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.strand\n \n \nFunction\n.\n\n\nstrand(record::Record)::GenomicFeatures.Strand\n\n\n\n\n\nGet the strand of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.phase\n \n \nFunction\n.\n\n\nphase(record::Record)::Int\n\n\n\n\n\nGet the phase of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.attributes\n \n \nFunction\n.\n\n\nattributes(record::Record)::Vector{Pair{String,Vector{String}}}\n\n\n\n\n\nGet the attributes of \nrecord\n.\n\n\nsource\n\n\nattributes(record::Record, key::String)::Vector{String}\n\n\n\n\n\nGet the attributes of \nrecord\n with \nkey\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.GFF3.content\n \n \nFunction\n.\n\n\ncontent(record::Record)::String\n\n\n\n\n\nGet the content of \nrecord\n. Leading '#' letters are removed.\n\n\nsource", 
            "title": "GFF3"
        }, 
        {
            "location": "/io/gff3/#gff3", 
            "text": "Reader type:  GenomicFeatures.GFF3.Reader  Writer type:  GenomicFeatures.GFF3.Writer  Element type:  GenomicFeatures.GFF3.Record   GFF3 is a text-based file format for representing genomic annotations. The major difference from BED is that is GFF3 is more structured and can include sequences in the FASTA file format.  #  GenomicFeatures.GFF3.Reader     Type .  GFF3Reader ( input :: IO ;   save_directives :: Bool = false )   Create a reader for data in GFF3 format.  Arguments:   input : data source  save_directives=false : if true, store directive lines, which can be accessed with the  directives  function   source  #  GenomicFeatures.GFF3.Writer     Type .  GFF3.Writer(output::IO)  Create a data writer of the GFF3 file format.  Arguments:   output : data sink   source  #  GenomicFeatures.GFF3.Record     Type .  GFF3.Record()  Create an unfilled GFF3 record.  source  GFF3.Record(data::Vector{UInt8})  Create a GFF3 record object from  data . This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  GFF3.Record(str::AbstractString)  Create a GFF3 record object from  str . This function verifies and indexes fields for accessors.  source  #  GenomicFeatures.GFF3.isfeature     Function .  isfeature(record::Record)::Bool  Test if  record  is a feature record.  source  #  GenomicFeatures.GFF3.isdirective     Function .  isdirective(record::Record)::Bool  Test if  record  is a directive record.  source  #  GenomicFeatures.GFF3.iscomment     Function .  iscomment(record::Record)::Bool  Test if  record  is a comment record.  source  #  GenomicFeatures.GFF3.seqid     Function .  seqid(record::Record)::String  Get the sequence ID of  record .  source  #  GenomicFeatures.GFF3.source     Function .  source(record::Record)::String  Get the source of  record .  source  #  GenomicFeatures.GFF3.featuretype     Function .  featuretype(record::Record)::String  Get the type of  record .  source  #  GenomicFeatures.GFF3.seqstart     Function .  seqstart(record::Record)::Int  Get the start coordinate of  record .  source  #  GenomicFeatures.GFF3.seqend     Function .  seqend(record::Record)::Int  Get the end coordinate of  record .  source  #  GenomicFeatures.GFF3.score     Function .  score(record::Record)::Float64  Get the score of  record  source  #  GenomicFeatures.GFF3.strand     Function .  strand(record::Record)::GenomicFeatures.Strand  Get the strand of  record .  source  #  GenomicFeatures.GFF3.phase     Function .  phase(record::Record)::Int  Get the phase of  record .  source  #  GenomicFeatures.GFF3.attributes     Function .  attributes(record::Record)::Vector{Pair{String,Vector{String}}}  Get the attributes of  record .  source  attributes(record::Record, key::String)::Vector{String}  Get the attributes of  record  with  key .  source  #  GenomicFeatures.GFF3.content     Function .  content(record::Record)::String  Get the content of  record . Leading '#' letters are removed.  source", 
            "title": "GFF3"
        }, 
        {
            "location": "/io/bigwig/", 
            "text": "bigWig\n\n\n\n\nReader type: \nBigWig.Reader\n\n\nWriter type: \nBigWig.Writer\n\n\nElement type: \nBigWig.Record\n\n\n\n\nbigWig is a binary file format for associating a floating point number with each base in the genome. bigWig files are indexed to quickly fetch specific regions.\n\n\n#\n\n\nGenomicFeatures.BigWig.Reader\n \n \nType\n.\n\n\nBigWig.Reader(input::IO)\n\n\n\n\n\nCreate a reader for bigWig file format.\n\n\nNote that \ninput\n must be seekable.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.chromlist\n \n \nFunction\n.\n\n\nchromlist(reader::BigWig.Reader)::Vector{Tuple{String,Int}}\n\n\n\n\n\nGet the \n(name, length)\n pairs of chromosomes/contigs.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.values\n \n \nFunction\n.\n\n\nvalues(reader::BigWig.Reader, interval::Interval)::Vector{Float32}\n\n\n\n\n\nGet a vector of values within \ninterval\n from \nreader\n.\n\n\nThis function fills missing values with \nNaN32\n.\n\n\nsource\n\n\nvalues(reader::BigWig.Reader, chrom::AbstractString, range::UnitRange)::Vector{Float32}\n\n\n\n\n\nGet a vector of values within \nrange\n of \nchrom\n from \nreader\n.\n\n\nThis function fills missing values with \nNaN32\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.Writer\n \n \nType\n.\n\n\nBigWig\n.\nWriter\n(\noutput\n::\nIO\n,\n \nchromlist\n;\n \nbinsize\n=\n64\n,\n \ndatatype\n=\n:\nbedgraph\n)\n\n\n\n\n\n\nCreate a data writer of the bigWig file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nchromlist\n: chromosome list with length\n\n\nbinsize=64\n: size of a zoom with the highest resolution\n\n\ndatatype=:bedgraph\n: encoding of values (\n:bedgraph\n, \n:varstep\n or \n:fixedstep\n)\n\n\n\n\nExamples\n\n\noutput\n \n=\n \nopen\n(\ndata.bw\n,\n \nw\n)\n\n\nwriter\n \n=\n \nBigWig\n.\nWriter\n(\noutput\n,\n \n[(\nchr1\n,\n \n12345\n),\n \n(\nchr2\n,\n \n9100\n)])\n\n\nwrite\n(\nwriter\n,\n \n(\nchr1\n,\n \n501\n,\n \n600\n,\n \n1.0\n))\n\n\nwrite\n(\nwriter\n,\n \n(\nchr2\n,\n \n301\n,\n \n450\n,\n \n3.0\n))\n\n\nclose\n(\nwriter\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.Record\n \n \nType\n.\n\n\nBigWig.Record()\n\n\n\n\n\nCreate an unfilled bigWig record.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::String\n\n\n\n\n\nGet the chromosome name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.chromid\n \n \nFunction\n.\n\n\nchromid(record::Record)::UInt32\n\n\n\n\n\nGet the chromosome ID of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.chromstart\n \n \nFunction\n.\n\n\nchromstart(record::Record)::Int\n\n\n\n\n\nGet the start position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.chromend\n \n \nFunction\n.\n\n\nchromend(record::Record)::Int\n\n\n\n\n\nGet the end position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigWig.value\n \n \nFunction\n.\n\n\nvalue(record::Record)::Float32\n\n\n\n\n\nGet the value of \nrecord\n.\n\n\nsource", 
            "title": "BigWig"
        }, 
        {
            "location": "/io/bigwig/#bigwig", 
            "text": "Reader type:  BigWig.Reader  Writer type:  BigWig.Writer  Element type:  BigWig.Record   bigWig is a binary file format for associating a floating point number with each base in the genome. bigWig files are indexed to quickly fetch specific regions.  #  GenomicFeatures.BigWig.Reader     Type .  BigWig.Reader(input::IO)  Create a reader for bigWig file format.  Note that  input  must be seekable.  source  #  GenomicFeatures.BigWig.chromlist     Function .  chromlist(reader::BigWig.Reader)::Vector{Tuple{String,Int}}  Get the  (name, length)  pairs of chromosomes/contigs.  source  #  GenomicFeatures.BigWig.values     Function .  values(reader::BigWig.Reader, interval::Interval)::Vector{Float32}  Get a vector of values within  interval  from  reader .  This function fills missing values with  NaN32 .  source  values(reader::BigWig.Reader, chrom::AbstractString, range::UnitRange)::Vector{Float32}  Get a vector of values within  range  of  chrom  from  reader .  This function fills missing values with  NaN32 .  source  #  GenomicFeatures.BigWig.Writer     Type .  BigWig . Writer ( output :: IO ,   chromlist ;   binsize = 64 ,   datatype = : bedgraph )   Create a data writer of the bigWig file format.  Arguments   output : data sink  chromlist : chromosome list with length  binsize=64 : size of a zoom with the highest resolution  datatype=:bedgraph : encoding of values ( :bedgraph ,  :varstep  or  :fixedstep )   Examples  output   =   open ( data.bw ,   w )  writer   =   BigWig . Writer ( output ,   [( chr1 ,   12345 ),   ( chr2 ,   9100 )])  write ( writer ,   ( chr1 ,   501 ,   600 ,   1.0 ))  write ( writer ,   ( chr2 ,   301 ,   450 ,   3.0 ))  close ( writer )   source  #  GenomicFeatures.BigWig.Record     Type .  BigWig.Record()  Create an unfilled bigWig record.  source  #  GenomicFeatures.BigWig.chrom     Function .  chrom(record::Record)::String  Get the chromosome name of  record .  source  #  GenomicFeatures.BigWig.chromid     Function .  chromid(record::Record)::UInt32  Get the chromosome ID of  record .  source  #  GenomicFeatures.BigWig.chromstart     Function .  chromstart(record::Record)::Int  Get the start position of  record .  source  #  GenomicFeatures.BigWig.chromend     Function .  chromend(record::Record)::Int  Get the end position of  record .  source  #  GenomicFeatures.BigWig.value     Function .  value(record::Record)::Float32  Get the value of  record .  source", 
            "title": "bigWig"
        }, 
        {
            "location": "/io/bigbed/", 
            "text": "bigBed\n\n\n\n\nReader type: \nBigBed.Reader\n\n\nWritre type: \nBigBed.Writer\n\n\nElement type: \nBigBed.Record\n\n\n\n\nbigBed is a binary file format for representing genomic annotations and often created from BED files. bigBed files are indexed to quickly fetch specific regions.\n\n\n#\n\n\nGenomicFeatures.BigBed.Reader\n \n \nType\n.\n\n\nBigBed.Reader(input::IO)\n\n\n\n\n\nCreate a reader for bigBed file format.\n\n\nNote that \ninput\n must be seekable.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.chromlist\n \n \nFunction\n.\n\n\nchromlist(reader::BigBed.Reader)::Vector{Tuple{String,Int}}\n\n\n\n\n\nGet the \n(name, length)\n pairs of chromosomes/contigs.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.Writer\n \n \nType\n.\n\n\nBigBed\n.\nWriter\n(\noutput\n::\nIO\n,\n \nchromlist\n;\n \nbinsize\n=\n64\n)\n\n\n\n\n\n\nCreate a data writer of the bigBed file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nchromlist\n: chromosome list with length\n\n\nbinsize=64\n: size of a zoom with the highest resolution\n\n\n\n\nExamples\n\n\noutput\n \n=\n \nopen\n(\ndata.bb\n,\n \nw\n)\n\n\nwriter\n \n=\n \nBigBed\n.\nWriter\n(\noutput\n,\n \n[(\nchr1\n,\n \n12345\n),\n \n(\nchr2\n,\n \n9100\n)])\n\n\nwrite\n(\nwriter\n,\n \n(\nchr1\n,\n \n101\n,\n \n150\n,\n \ngene 1\n))\n\n\nwrite\n(\nwriter\n,\n \n(\nchr2\n,\n \n211\n,\n \n250\n,\n \ngene 2\n))\n\n\nclose\n(\nwriter\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.Record\n \n \nType\n.\n\n\nBigBed.Record()\n\n\n\n\n\nCreate an unfilled bigBed record.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.chrom\n \n \nFunction\n.\n\n\nchrom(record::Record)::String\n\n\n\n\n\nGet the chromosome name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.chromid\n \n \nFunction\n.\n\n\nchromid(record::Record)::UInt32\n\n\n\n\n\nGet the chromosome ID of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.chromstart\n \n \nFunction\n.\n\n\nchromstart(record::Record)::Int\n\n\n\n\n\nGet the start position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.chromend\n \n \nFunction\n.\n\n\nchromend(record::Record)::Int\n\n\n\n\n\nGet the end position of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.name\n \n \nFunction\n.\n\n\nname(record::Record)::String\n\n\n\n\n\nGet the name of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.score\n \n \nFunction\n.\n\n\nscore(record::Record)::Int\n\n\n\n\n\nGet the score between 0 and 1000.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.strand\n \n \nFunction\n.\n\n\nstrand(record::Record)::GenomicFeatures.Strand\n\n\n\n\n\nGet the strand of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.thickstart\n \n \nFunction\n.\n\n\nthickstart(record::Record)::Int\n\n\n\n\n\nGet the starting position at which \nrecord\n is drawn thickly.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.thickend\n \n \nFunction\n.\n\n\nthickend(record::Record)::Int\n\n\n\n\n\nGet the end position at which \nrecord\n is drawn thickly.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.itemrgb\n \n \nFunction\n.\n\n\nitemrgb(record::Record)::ColorTypes.RGB\n\n\n\n\n\nGet the RGB value of \nrecord\n.\n\n\nThe return type is defined in \nColorTypes.jl\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.blockcount\n \n \nFunction\n.\n\n\nblockcount(record::Record)::Int\n\n\n\n\n\nGet the number of blocks (exons) in \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.blocksizes\n \n \nFunction\n.\n\n\nblocksizes(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) sizes of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.blockstarts\n \n \nFunction\n.\n\n\nblockstarts(record::Record)::Vector{Int}\n\n\n\n\n\nGet the block (exon) starts of \nrecord\n.\n\n\nNote that the first base is numbered 1.\n\n\nsource\n\n\n#\n\n\nGenomicFeatures.BigBed.optionals\n \n \nFunction\n.\n\n\noptionals(record::Record)::Vector{String}\n\n\n\n\n\nGet optional fields as strings.\n\n\nsource", 
            "title": "BigBed"
        }, 
        {
            "location": "/io/bigbed/#bigbed", 
            "text": "Reader type:  BigBed.Reader  Writre type:  BigBed.Writer  Element type:  BigBed.Record   bigBed is a binary file format for representing genomic annotations and often created from BED files. bigBed files are indexed to quickly fetch specific regions.  #  GenomicFeatures.BigBed.Reader     Type .  BigBed.Reader(input::IO)  Create a reader for bigBed file format.  Note that  input  must be seekable.  source  #  GenomicFeatures.BigBed.chromlist     Function .  chromlist(reader::BigBed.Reader)::Vector{Tuple{String,Int}}  Get the  (name, length)  pairs of chromosomes/contigs.  source  #  GenomicFeatures.BigBed.Writer     Type .  BigBed . Writer ( output :: IO ,   chromlist ;   binsize = 64 )   Create a data writer of the bigBed file format.  Arguments   output : data sink  chromlist : chromosome list with length  binsize=64 : size of a zoom with the highest resolution   Examples  output   =   open ( data.bb ,   w )  writer   =   BigBed . Writer ( output ,   [( chr1 ,   12345 ),   ( chr2 ,   9100 )])  write ( writer ,   ( chr1 ,   101 ,   150 ,   gene 1 ))  write ( writer ,   ( chr2 ,   211 ,   250 ,   gene 2 ))  close ( writer )   source  #  GenomicFeatures.BigBed.Record     Type .  BigBed.Record()  Create an unfilled bigBed record.  source  #  GenomicFeatures.BigBed.chrom     Function .  chrom(record::Record)::String  Get the chromosome name of  record .  source  #  GenomicFeatures.BigBed.chromid     Function .  chromid(record::Record)::UInt32  Get the chromosome ID of  record .  source  #  GenomicFeatures.BigBed.chromstart     Function .  chromstart(record::Record)::Int  Get the start position of  record .  source  #  GenomicFeatures.BigBed.chromend     Function .  chromend(record::Record)::Int  Get the end position of  record .  source  #  GenomicFeatures.BigBed.name     Function .  name(record::Record)::String  Get the name of  record .  source  #  GenomicFeatures.BigBed.score     Function .  score(record::Record)::Int  Get the score between 0 and 1000.  source  #  GenomicFeatures.BigBed.strand     Function .  strand(record::Record)::GenomicFeatures.Strand  Get the strand of  record .  source  #  GenomicFeatures.BigBed.thickstart     Function .  thickstart(record::Record)::Int  Get the starting position at which  record  is drawn thickly.  Note that the first base is numbered 1.  source  #  GenomicFeatures.BigBed.thickend     Function .  thickend(record::Record)::Int  Get the end position at which  record  is drawn thickly.  source  #  GenomicFeatures.BigBed.itemrgb     Function .  itemrgb(record::Record)::ColorTypes.RGB  Get the RGB value of  record .  The return type is defined in  ColorTypes.jl .  source  #  GenomicFeatures.BigBed.blockcount     Function .  blockcount(record::Record)::Int  Get the number of blocks (exons) in  record .  source  #  GenomicFeatures.BigBed.blocksizes     Function .  blocksizes(record::Record)::Vector{Int}  Get the block (exon) sizes of  record .  source  #  GenomicFeatures.BigBed.blockstarts     Function .  blockstarts(record::Record)::Vector{Int}  Get the block (exon) starts of  record .  Note that the first base is numbered 1.  source  #  GenomicFeatures.BigBed.optionals     Function .  optionals(record::Record)::Vector{String}  Get optional fields as strings.  source", 
            "title": "bigBed"
        }
    ]
}